My part of this project milestone-2 implements a Minecraft-style terrain engine with multithreaded chunk and VBO generation.

My Point was to:
Make terrain generation:
    Efficient: No lag spikes when exploring
    Dynamic: Expands naturally around the player
    Thread-safe: Avoid race conditions and OpenGL crashes


Zones and Chunks

    The world is divided into 64×64 “zones”, each containing 16×16 “chunks”.
    As the player moves, I track which zones are near and load chunks only when needed.

Threads for Chunk Work
    1. Each new zone gets its own thread (capped!).
    2. Inside each thread:
        I generate terrain block data.
        I push finished chunks into a queue.
    3. VBO generation happens on a background thread too.
    4. OpenGL buffer uploads only happen on the main thread.

How I Made It Safe
    std::atomic<int> activeZoneThreads;
    const int MAX_ACTIVE_ZONE_THREADS = 6;

    This avoids spawning too many threads at once.
    Before launching a thread, I check this count and bump it up. When a thread finishes, I decrement it.

No OpenGL in Threads!
VBO creation is split:
    createVBOdata() is threaded (pure CPU)
    bufferInterleaved() is always called on the main thread, in consumeChunkWork()

Every tick:

    1. I check if the player is near a zone that hasn’t been generated.
    2. If yes, and we haven’t hit the thread cap:
            Start a thread.
            Generate chunk data.
            Enqueue for VBO processing.
    3. In tick():
            I process the VBO queue.
            This avoids lag from blocking OpenGL calls.

A few problems I had in the beginning:

    1. Terrain not expanding near player
    2. Massive stutter when chunks loaded
    3. Threads stepping on each other

Now, with proper capping, mutexing, and responsible OpenGL access, everything works.
