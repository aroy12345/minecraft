I implemented the texture and texture animation feature of the milestone2. 
I first loaded the texture png file in mygl::initializeGL() function. The first problem I encountered was actually loading the texture file, because it just 
kept saying no texture file was open. Then, I asked a TA about it and he told me to add it to the glsl.qrc, then it worked! I then enabled the alpha blending
to allow the transparent water blocks during rendering, 
And then I work on the vertex shader, i added UV variables (vs_UV, fs_UV). I pass vs_UV as a vec4, and use the xy coord of vs_UV as fs_UV, and its z coord to
flag whether its animated or not. So, then in the frag shader, i sampled the animation texture with time-based offset, and combined texColor with lighting
for the final frag color.
I extended the interleaved vbo to now store position, normal, color, uv (all vec4). In Chunk::createFace(), icalculated a baseUV per block type/face by 
normalizing tile coordinates within the 16×16 grid. I populated vboData.opaqueVBO / vboData.opaqueIndex for solid blocks, vboData.transparentVBO / vboData.transparentIndex 
for transparent blocks like water. In bufferInterleaved(), generated and bound distinct buffers for opaque (OPAQUE_INTERLEAVED + OPAQUE_INDEX) and transparent 
(TRANSPARENT_INTERLEAVED + TRANSPARENT_INDEX) to enforce correct draw order.

In shaderprogram, I also extended parseShaderSourceForVariables() to detect vs_UV, u_Texture, and u_Time as active attributes/uniforms and Updated 
drawInterleaved() to compute a stride of 4 * sizeof(glm::vec4) and set attribute pointers at offsets 0 (pos), 1×vec4 (norm), 2×vec4 (col), 3×vec4 (UV).

Bind texture unit and set uniforms each frame:
texture->bind(0);
m_progLambert.setUnifInt("u_Texture", 0);
m_progLambert.setUnifFloat("u_Time", m_currentTime);

Opaque pass: draw all solid-block VBOs.
Transparent pass: ensure blending enabled and draw transparent VBOs last.
